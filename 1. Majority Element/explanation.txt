ðŸ§© Problem: Majority Element

Difficulty: Easy

The task is to find the element that appears more than âŒŠn/2âŒ‹ times in an array.

ðŸ¥‡ Approach 1: Brute Force

Logic:
For every element, count its frequency in the array.
If any elementâ€™s count > n/2, thatâ€™s the majority element.

Code (Python):

def majorityElement(nums):
    n = len(nums)
    for i in range(n):
        count = 0
        for j in range(n):
            if nums[j] == nums[i]:
                count += 1
        if count > n // 2:
            return nums[i]


Time Complexity: O(nÂ²) â€“ checking each elementâ€™s frequency
Space Complexity: O(1) â€“ no extra space used

ðŸ¥ˆ Approach 2: Sorting Method

Logic:
If an element occurs more than n/2 times, it will always occupy the middle position after sorting.

Code (Python):

def majorityElement(nums):
    nums.sort()
    return nums[len(nums)//2]


Time Complexity: O(n log n) â€“ due to sorting
Space Complexity: O(1) â€“ if sorting done in place

ðŸ¥‡ Approach 3: Boyerâ€“Moore Voting Algorithm

Logic:
Use a counter.

Pick a candidate and increase count if the same, decrease otherwise.

The remaining candidate after one full pass is the majority element.

Code (Python):

def majorityElement(nums):
    count = 0
    candidate = None

    for num in nums:
        if count == 0:
            candidate = num
        count += (1 if num == candidate else -1)
    
    return candidate


Time Complexity: O(n) â€“ single pass through array
Space Complexity: O(1) â€“ only two variables used

âœ… Final Submission

The Boyerâ€“Moore Algorithm was submitted since itâ€™s the most efficient in both time and space.